## 题目

实现函数 `atoi`，把字符串转化为整数。

该函数首先丢弃所需数量的空白字符，直到找到一个非空白字符。然后，从该字符开始，处理可选的初始正号或负号，后跟尽可能多的数字，并将它们解释为数值。

字符串可以包含在形成整数之后的其他字符，这些字符被忽略并且对此函数的行为没有影响。

如果 `str` 中的第一个非空白字符序列不是有效的整数，或者由于 `str` 是空的或者只包含空白字符，则不执行转换。

如果无法执行有效转换，则返回零值。

注意：

- 只有空格字符 ' ' 被视为空白字符。

- 假设我们正在的环境只能处理 32 位有符号整数，范围是 `[-2^31, 2^31 - 1]`。如果数值超出可表示值的范围，则返回 `INT\_MAX (2^31 - 1)` 或 `INT\_MIN (-2^31)`。

例1：

输入：`"42"`

输出：`42`

例2：

输入：`"-42"`

输出：`42`

说明：第一个非空白字符是 `'-'`，这是负号。

例3：

输入：`"4193 with words"`

输出：`4193`

说明：在字符 `'3'` 处停止转化，因为下一个字符不是数字字符。

例4：

输入：`"words and 987"`

输出：`0`

说明：第一个非空白字符是 `'w'`，不是数字字符或正负号，所以不能进行合法的转化。

例5：

输入：`"-91283472332"`

输出：`-2147483648`

说明：数字 `"-91283472332"` 超出了 32 位整数的范围，所以返回 `INT\_MIN (-2^31)`。

## 思路

1. 一个偷懒的做法，肯定能过，但是这样体现不出这道题练习的目的：调用系统提供的 `Integer.parseInt` 函数。

> 把开头的空白符去掉。
> 判断符号位。
> 过一遍字符串，到非数字字符。
> 截取子串。
> 判断：空串或都只有符号位，都是非法的，返回 `0`。
> 调用 `Integer.parseInt` 函数，`catch` 异常，如果 `catch` 到异常，说明数字超出了范围，根据符号位返回规定的值。
> 如果没有 `catch` 到异常，正常返回转化之后的整数。

2. 手动实现。

> 其他都简单，关键是怎么样判断越界的问题。
> 每读进来一位数字，都要进行一次乘法和一次加法，
> 在乘法之前，判断乘法会不会越界，加法之前，判断加法会不会越界。
> 由于转化过程中，处理的都是正数，所以判断方式很简单粗暴：
> 乘法不越界的条件是：`(x*y)/x == y`
> 加法不越界的条件是：`x+y >= 0`

## 运行结果

偷懒的做法：24ms，超过 74.07% 的 Java 提交。
手动实现：  23ms，超过 88.89% 的 Java 提交。
