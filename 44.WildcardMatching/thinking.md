## 题目

给定一个字符串 `(s)` 和一个字符模式 `(p)` ，实现一个支持 `'?'` 和 `'*'` 的通配符匹配。

> `'?'` 可以匹配任何单个字符。\
> `'*'` 可以匹配任何任意字符串（包括空字符串）。

两个字符串**完全匹配**才算匹配成功。

#### 说明

> + `s` 可能为空，且只包含 `a-z` 的小写字母。\
> + `p` 可能为空，且只包含 `a-z` 的小写字母，以为字符 `?` 和 `*`。

#### 示例1：

> **输入**：\
> `s = "aa"`\
> `p = "a"`\
> **输出**：`false`\
> **解释**：`"a"` 无法匹配 `"aa"` 整个字符串。

#### 示例2：

> **输入**：\
> `s = "aa"`\
> `p = "*"`\
> **输出**：`true`\
> **解释**：`'*'` 可以匹配任意字符串。

#### 示例3：

> **输入**：\
> `s = "cb"`\
> `p = "?a"`\
> **输出**：`false`\
> **解释**：`'?'` 可以匹配 `'c'`, 但第二个 `'a'` 无法匹配 `'b'`。

#### 示例4：

> **输入**：\
> `s = "adceb"`\
> `p = "*a*b"`\
> **输出**：`true`\
> **解释**：第一个 `'*'` 可以匹配空字符串, 第二个 `'*'` 可以匹配字符串 `"dce"`。

#### 示例5：

> **输入**：\
> `s = "acdcb"`\
> `p = "a*c?b"`\
> **输出**：`false`

## 思路

此题与第 10 题异曲同工，但是对于递归算法而言，有着本质不同。原因是，对于递归算法来说，第 10 题中，由于 `*` 只代表数量，所以其前面必须有一个字母或通配符，如果是字母的话，可以提前判断出循环终止的条件。但是本题中，`*` 是代表任意字符串，也就是相当于， 第 10 题的所有测试用例中，带 `*` 的子串都是 `.*`，这无疑加大了难度和搜索时间，而且永远无法提前退出。重复算的东西太多。第 10 题递归算法可以通过，完全是因为运气，如果第 10 题的最长的测试用例中，所有的 `*` 前面都是 `.`，肯定会超时的。尤其是，如果第 10 题中 `.*` 这样的组合连续出现，或者是本题中 `*` 连续出现，这种重复计算量将是不可想象的。经过实际提交代码进行 Judge，已经印证了这个结论：在本题中，用递归算法是会超时的。

所以，必须使用**动态规划**来做解决本题。

## 运行结果

执行用时：39 ms，超过 26.72% 的 Java 提交。
