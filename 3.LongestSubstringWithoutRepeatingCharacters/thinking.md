## 题目

给一个字符串，返回这个字符串中最长的不含重复字符的子串（注意是子串，不是子序列。子串是连续的，子序列可以不连续）。

例1：

输入：`abcabcbb`

输出：`3`

说明：答案是 `abc`，长度是 `3`.

例2：

输入：`bbbbb`

输出：`1`

说明：答案是 `b`，长度是 `1`.

例3：

输入：`pwwkew`

输出：`3`

说明：答案是 `wke`，长度是 `3`.
**注意**答案是子串，`pwke` 是子序列而不是子串。

## 解题思路

这题有点意思。不知道数据量多大，暴搜我没试，不知道能不能过。我用的是更高效的方法。

首先讨论，怎样记录字符是否出现过的问题，比较高效的方法，一个是用哈希表，一个是用布尔数组。这是一维的，就是只记录字符是否存在，没有其他信息。下文中，我的算法不仅需要知道字符是否存在，还要知道字符在哪个位置存在，这时用 `HashMap` 最合适不过了。可以认为，`HashSet` 和 `HashMap` 的查找时间复杂度为 O(1)。

先说暴搜，思路就是两重循环，外层代表子串的开始位置，一位一位地往后移，在进入内层循环之前，要清空记录，认为所有字符都没出现过；内层代表子串的结束位置，每移一位，都要查表看这个字符是否出现过，记录子串长度。当遇到一个已出现的字符时，看子串长度是否是目前找到的最长的，更新结果。

暴搜的时间复杂度不用想，是 O(n^2)。当然有更好的方法，比如我的方法。试想，子串的开始位置，需要每次都只移一位吗？如果子串结尾所遇到的重复字符，知道它出现在之前的什么位置，那么是不是可以直接把子串开始位置移到那个位置之后呢？当然可以！而且，结束位置也不需要从开始位置这里开始搜，而是在重复字符之处接着搜。这样，时间复杂度就可以降到 O(n)。

举个例子：
```
abcdecfghgijkabcde
^    ^
```
此处有重复字符 c，则接着找时，从这个位置开始：
```
abcdecfghgijkabcde
   ^  ^
```
又遇到重复字符时，是在：
```
abcdecfghgijkabcde
   ^     ^
```
则从这个位置接着找：
```
abcdecfghgijkabcde
        ^ ^
```
注意，找到最后时，
```
abcdecfghgijkabcde
        ^        ^
```
我的 `while` 循环退出，但是还未更新结果，要加上更新的结果。

题目中还有一个小坑，要小心：输入有可能是空串，此时要输出 `0`.

【运行结果】

32ms，超过 74.29% 的 Java 提交。
