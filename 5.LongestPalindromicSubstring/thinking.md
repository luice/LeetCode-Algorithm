## 题目

给定一个字符串 s，找出 s 的最长回文子串。可以假设 s 的最大长度为 1000.

例1：

输入：`babad`

输出：`bab`

说明：`aba` 也是一个有效答案。

例2：

输入：`cbbd`

输出：`bb`

## 解题思路

三种方法：

### 方法一：暴力求解。

验证每一个子串是不是回文。

找每一个子串，时间复杂度是 O(n^2)，验证回文，又乘了一个 n，所以暴力算法的时间复杂度是 O(n^3)。

这种方法最直观，三层循环嵌套即可。

### 方法二：从中心向两边扩散。

外面一层循环，以某个字符为中心，里面一层循环，向外扩散，验证是否是回文。

这种方法只有两层循环，所以时间复杂度是 O(n^2)。

### 方法三：Manacher 算法。

**转载自[博客](https://blog.csdn.net/qq_32354501/article/details/80084325)**

**原博客中的代码是错误的，我做了修正。**

先把字符串 s 变为一个新的字符串 s\_new，在 s 的每两个字符中间和开头结尾都插入一个相同的、s 中不会出现的字符。
定义一个数组 len[]，len[i] 表示以 s\_new[i] 为中心的最大回文串中最右端的字符到中心（含）的字符数。

例如：
```
index:  0  1  2  3  4  5  6  7  8  9  10 11 12 13 14
s     = a  a  b  a  b  b  a
s_new = #  a  #  a  #  b  #  a  #  b  #  b  #  a  #
len   = 1  2  3  2  1  4  1  4  1  2  5  2  1  2  1
```
比如 `len[5]`，表示 `s_new` 中，以 `s_new[5]` 为中心的最长回文子串 `#a#b#a#` 最右端到中心的字符数，即下标 `5 6 7 8` 所含的字符数，为 `4`。

`len` 有如下性质：`len[i]-1` 即为以 `s_new[i]` 为中心的最长回文子串在 `s` 中的长度。

关于 `len` 数组的求解，有一个 O(n) 时间复杂度的方法：

1. 遍历 `s_new` 数组，i 为当前遍历到的位置，即求解以 `s_new[i]` 为中心的最长回文子串的 `len[i]`；

2. 设置两个参数：`sub_midd = len.indexOf(Math.max(Len)`，表示在 `i` 之前所得到的 `len` 数组中的最大值所在位置、`sub_side = sub_midd + len[sub_midd] - 1`，表示以 `sub_midd` 为中心的最长回文子串的最右端在 `s_new` 中的位置。起始 `sub_midd` 和 `sub_side` 设为 `0`，从 `s_new` 中的第一个字母开始计算，每次计算后都需要更新 `sub_midd` 和 `sub_side`；

3. 当 `i <= sub_side` 时，取 `i` 关于 `sub_midd` 的对称点 `j（j = 2sub_midd - i`，由于 `i <= sub_side`，因此 `2sub_midd - sub_side <= j <= sub_midd`)；
当 `len[j] <= sub_side - i` 时，即以 `s_new[j]` 为中心的最长回文子串是在以 `s_new[sub_midd]` 为中心的最长回文子串的内部，再由于 `i`、`j` 关于 `sub_midd` 对称，可知 `len[i] = len[j]`；
当 `len[j] > sub_side - i +1` 时，以 `j` 为中心的最长回文子串延伸到了以 `sub_midd` 为中心的最长回文子串之外，但是以 `i` 为中心的最长回文子串的最右端只能是到 `sub_side`，不多也不少。因为 `i` 和 `j` 是关于 `sub_midd` 对称的，在 `2*sub_midd-sub_side` 到 `sub_side` 之间，字符串是对称的，而以 `j` 为中心的从 `2*sub_midd-sub_side` 开始的串是回文串，这就是说，从 `2*i-sub_side` 到 `sub_side` 这一段是回文串。由于 `len[j] > sub_side-i`，所以如果以 `i` 为中心的最长回文串超过了 `sub_side`，那么由对称性可知，超过的部分也是关于 `sub_midd` 对称的，这就与我们假设的 `sub_side` 是以 `sub_midd` 为中心的最长回文串的最右端相矛盾；
当 `len[j] = sub_side - i + 1` 时，`i` 可能是新的中心，因为这时以 `j` 为中心的最长回文子串的左端与以 `sub_midd` 为中心的最长回文子串的左端重合，此时若以 `i` 为中心的回文子串比以 `j` 为中心的最长回文子串更长，也不影响 `sub_midd` 与 `sub_side` 的关系正确性。此时要接着匹配，但不必从 `i` 开始，可以以 `i` 为中心从 `sub_side` 开始。

4. 当 `i > sub_side` 时，则说明以 `s_new[i]` 为中心的最长回文子串还没开始匹配寻找，因此需要一个一个进行匹配寻找，结束后更新 `sub_side` 和对应的 `sub_midd` 以及 `len[i]`。

关于这个算法的时间复杂度：

算法只有遇到还没匹配的位置时才进行匹配，已经匹配过的位置不再进行匹配，因此大大的减少了重复匹配的步骤，对于 s\_new 中的每个字符只进行一次匹配。所以该算法的时间复杂度为 O(2n+1) 即 O(n)（n为原字符串的长度），所以其时间复杂度依旧是线性的。

## 运行结果
31ms，性能超过 56.92% 的 Java 提交。
